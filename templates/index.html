<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNXè½¬TFLiteè½¬æ¢å™¨</title>
    <style>
        /* Tailwind-inspired System Font Stack & Colors */
        :root {
            /* Neutrals */
            --bg-body: #f3f4f6; /* gray-100 */
            --bg-white: #ffffff;
            --text-primary: #111827; /* gray-900 */
            --text-secondary: #4b5563; /* gray-600 */
            --border-color: #e5e7eb; /* gray-200 */
            
            /* Accents */
            --accent-blue: #3b82f6; /* blue-500 */
            --accent-hover: #2563eb; /* blue-600 */
            --success: #10b981; /* emerald-500 */
            --warning: #f59e0b; /* amber-500 */
            --danger: #ef4444; /* red-500 */
            
            /* Shadows & Radius */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --rounded: 0.375rem; /* 6px */
            --rounded-lg: 0.5rem; /* 8px */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        
        body { background: var(--bg-body); color: var(--text-primary); height: 100vh; display: flex; flex-direction: column; overflow: hidden; font-size: 0.875rem; /* 14px */ }

        /* Header */
        header {
            height: 56px; background: var(--bg-white); border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem;
            box-shadow: var(--shadow-sm); z-index: 50;
        }
        header h1 { font-size: 1.125rem; font-weight: 700; color: var(--text-primary); letter-spacing: -0.025em; }
        header .status { font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); background: #f3f4f6; padding: 0.25rem 0.75rem; border-radius: 9999px; }
        header .copyright { font-size: 0.7rem; color: #9ca3af; margin-right: 1rem; font-weight: 400; }

        /* Layout */
        main { flex: 1; display: grid; grid-template-columns: 280px 300px 1fr 450px; height: calc(100vh - 56px); }
        
        /* Panels */
        .panel { display: flex; flex-direction: column; overflow-y: auto; background: var(--bg-white); border-right: 1px solid var(--border-color); }
        .panel-center { background: #f9fafb; padding: 1.5rem; position: relative; border-right: 1px solid var(--border-color); overflow: hidden; display: flex; flex-direction: column; gap: 1rem; }
        .panel-right { border-left: none; } /* already handled by border-right of center if specific order, but keeping standard */

        /* Sections */
        .section { padding: 1.25rem; border-bottom: 1px solid var(--border-color); }
        .section-title { 
            font-size: 0.75rem; text-transform: uppercase; color: #6b7280; font-weight: 700; 
            margin-bottom: 0.75rem; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.5rem;
        }

        /* Forms & Inputs */
        .setting-group { margin-bottom: 1rem; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; padding: 0.375rem 0; font-size: 0.825rem; color: #374151; }
        .setting-row label { cursor: pointer; }

        input[type="checkbox"] { 
            appearance: none; background-color: #fff; margin: 0; font: inherit; color: currentColor;
            width: 1.15em; height: 1.15em; border: 1px solid #d1d5db; border-radius: 0.25rem;
            display: grid; place-content: center; cursor: pointer;
        }
        input[type="checkbox"]::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0); transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em white; transform-origin: center; clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        input[type="checkbox"]:checked { background-color: var(--accent-blue); border-color: var(--accent-blue); }
        input[type="checkbox"]:checked::before { transform: scale(1); }

        input[type="text"] {
            width: 100%; border: 1px solid #d1d5db; border-radius: var(--rounded); padding: 0.5rem 0.75rem;
            font-size: 0.875rem; margin-top: 0.25rem; transition: border-color 0.15s ease-in-out; outline: none;
        }
        input[type="text"]:focus { border-color: var(--accent-blue); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); }

        /* Buttons */
        .btn {
            display: inline-flex; justify-content: center; align-items: center; width: 100%;
            padding: 0.5rem 1rem; border: 1px solid transparent; border-radius: var(--rounded);
            font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.15s ease-in-out;
            margin-top: 0.75rem;
        }
        .btn-primary { background-color: var(--accent-blue); color: white; }
        .btn-primary:hover { background-color: var(--accent-hover); }
        .btn-primary:disabled { background-color: #9ca3af; cursor: not-allowed; }
        
        .btn-secondary { background-color: white; border-color: #d1d5db; color: #374151; }
        .btn-secondary:hover { background-color: #f9fafb; border-color: #9ca3af; }

        .upload-box {
            border: 2px dashed #e5e7eb; border-radius: var(--rounded-lg); padding: 2rem 1rem;
            text-align: center; cursor: pointer; transition: all 0.2s; background: #f9fafb; color: #6b7280;
        }
        .upload-box:hover { border-color: var(--accent-blue); color: var(--accent-blue); background: #eff6ff; }
        .upload-box.active { border-color: var(--accent-blue); background: #eff6ff; }

        /* Graph Card */
        #graphContainer { 
            background: white; border-radius: var(--rounded-lg); 
            box-shadow: var(--shadow-md); border: 1px solid #e5e7eb; 
            width: 100%; height: 100%; overflow: hidden; position: relative;
            cursor: grab;
        }
        #graphContainer.grabbing { cursor: grabbing; }
        
        /* Graph Canvas Styles */
        #graphCanvas { 
            width: 100%; 
            height: 100%; 
            display: block;
        }
        
        .graph-controls {
            position: absolute; top: 12px; right: 12px; display: flex; gap: 6px;
            background: white; padding: 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .graph-controls button {
            width: 28px; height: 28px; border: 1px solid #e5e7eb; background: white;
            border-radius: 4px; cursor: pointer; display: flex; align-items: center;
            justify-content: center; font-size: 14px; transition: all 0.15s;
        }
        .graph-controls button:hover { background: #f3f4f6; border-color: #3b82f6; }
        .graph-controls button.active { background: #3b82f6; color: white; border-color: #3b82f6; }

        /* Helpers */
        .hidden { display: none !important; }
        .badge { background: #e5e7eb; color: #374151; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; }

        /* List & Logs */
        .op-list { flex: 1; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: var(--rounded); padding: 0.5rem; }
        .op-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem; font-size: 0.85rem; color: #4b5563; }
        .op-item:hover { background: #f3f4f6; border-radius: 4px; }

        .console { background: #111827; color: #e5e7eb; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 0.75rem; padding: 1rem; overflow-y: auto; line-height: 1.5; }
        .log-info { color: #60a5fa; }
        .log-error { color: #f87171; }
        .log-success { color: #34d399; }

        .stat-card { background: #f9fafb; padding: 1rem; border-radius: var(--rounded); border: 1px solid #e5e7eb; margin-bottom: 0.5rem; }
        .stat-row { display: flex; justify-content: space-between; font-size: 0.85rem; color: #4b5563; margin-bottom: 0.25rem; }
        .stat-val { font-weight: 600; color: #111827; font-family: ui-monospace, monospace; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
    </style>
</head>
<body>
    <header>
        <h1>ONNX è½¬ TFLite è½¬æ¢å™¨ <span style="font-size:0.75em; color:#9ca3af; font-weight:400; margin-left:8px;">ä¸“ä¸šç‰ˆ</span></h1>
        <div style="display: flex; align-items: center;">
            <div class="copyright">Â© 2026 è¿œå³°ç§‘æŠ€ ç‰ˆæƒæ‰€æœ‰</div>
            <div class="status" id="statusText">å°±ç»ª</div>
        </div>
    </header>

    <main>
        <!-- LEFT: Controls -->
        <div class="panel">
            <!-- 1. Model Upload -->
            <div class="section">
                <div class="section-title">1. è¾“å…¥æ¨¡å‹</div>
                <div class="upload-box" id="dropZone">
                    <svg style="width:24px;height:24px;margin-bottom:8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                    <div style="font-size: 0.875rem; font-weight: 500;">æ‹–å…¥ ONNX æ¨¡å‹</div>
                    <div id="fileName" style="font-size: 0.75rem; margin-top: 4px; color: var(--accent-blue);"></div>
                </div>
                <input type="file" id="fileInput" hidden accept=".onnx">
            </div>

            <!-- 2. Converter Settings -->
            <div class="section">
                <div class="section-title">2. è½¬æ¢è®¾ç½®</div>
                
                <div class="setting-group">
                    <div class="setting-row">
                        <label>å…è®¸å‰¥ç¦»è¾“å…¥ (Strip Inputs)</label>
                        <input type="checkbox" id="allowInputsStripping">
                    </div>
                    <div class="setting-row">
                        <label>ä¿æŒ IO æ ¼å¼ (NCHW)</label>
                        <input type="checkbox" id="keepIoFormat">
                    </div>
                    <div class="setting-row">
                        <label>è·³è¿‡å½¢çŠ¶æ¨æ–­</label>
                        <input type="checkbox" id="skipShapeInference">
                    </div>
                     <div class="setting-row">
                        <label>å…è®¸ Select Ops (Flex)</label>
                        <input type="checkbox" id="allowSelectOps">
                    </div>
                     <div class="setting-row">
                        <label>å¼ºåˆ¶è½¬æ¢ Int64->32</label>
                        <input type="checkbox" id="castInt64ToInt32">
                    </div>
                </div>

                <div class="setting-group">
                    <div style="font-size: 0.75rem; font-weight: 700; color: #6b7280; margin-bottom: 0.5rem;">ç¬¦å·ç»´åº¦ (Symbolic Dims)</div>
                    <div style="margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                         <input type="checkbox" id="defaultDims">
                         <label for="defaultDims" style="font-size: 0.825rem; color: #374151;">ä½¿ç”¨é»˜è®¤ (batch=1, seq=50)</label>
                    </div>
                    <input type="text" id="symbolicDims" placeholder="ä¾‹å¦‚: batch_size=1, sequence_length=50">
                </div>

                 <button class="btn btn-primary" id="convertBtn" disabled>å¼€å§‹è½¬æ¢</button>
            </div>
        </div>

        <div class="panel">
            <!-- 3. Quantization -->
            <div class="section" style="flex:1; display:flex; flex-direction:column; border-bottom: none;">
                <div class="section-title" style="justify-content: space-between;">
                    <span>3. é‡åŒ–é…ç½® (QDQ)</span>
                </div>
                
                <div id="quantPanel" style="flex:1; display:flex; flex-direction:column; gap: 1rem;">
                    <div class="setting-group" style="margin-bottom:0;">
                        <div class="setting-row">
                            <label>Per-Channel é‡åŒ–</label>
                            <input type="checkbox" id="perChannel" checked>
                        </div>
                         <div class="setting-row">
                            <label>å…è®¸ Opset <= 10</label>
                            <input type="checkbox" id="allowOpset10">
                        </div>
                    </div>

                    <div style="border: 1px solid #e5e7eb; padding: 1rem; border-radius: var(--rounded); background: #f9fafb;">
                        <div style="font-size: 0.75rem; font-weight: 600; color: #374151; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            æ ¡å‡†æ•°æ®é›† (ZIP)
                            <button id="downloadExampleBtn" style="font-size: 0.65rem; padding: 2px 6px; border: 1px solid #bfdbfe; background: #eff6ff; color: #1e40af; border-radius: 4px; cursor: pointer; font-weight: 500;" title="ä¸‹è½½ç”Ÿæˆæ ¡å‡†æ•°æ®çš„ç¤ºä¾‹ç¨‹åº">ğŸ“ ç¤ºä¾‹</button>
                        </div>
                        <button class="btn btn-secondary" id="uploadCalibBtn" style="margin-top:0; font-size: 0.8rem; padding: 0.375rem;">é€‰æ‹©æ–‡ä»¶...</button>
                        <input type="file" id="calibInput" hidden accept=".zip">
                        <div id="calibInfo" style="font-size: 0.75rem; color: var(--success); margin-top: 0.5rem; font-weight: 500;"></div>
                    </div>

                    <div style="flex:1; display:flex; flex-direction:column; min-height: 0;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 0.5rem;">
                             <div style="font-size: 0.75rem; font-weight: 600; color: #374151;">é€‰æ‹©é‡åŒ–å±‚</div>
                             <div style="display: flex; gap: 4px;">
                                 <button id="btnSelectAll" style="font-size: 0.7rem; padding: 2px 6px; border: 1px solid #d1d5db; background: white; border-radius: 4px; cursor: pointer;">å…¨é€‰</button>
                                 <button id="btnClearAll" style="font-size: 0.7rem; padding: 2px 6px; border: 1px solid #d1d5db; background: white; border-radius: 4px; cursor: pointer;">æ¸…ç©º</button>
                             </div>
                        </div>
                        <div class="op-list" id="layerList">
                            <div style="text-align:center; color:#9ca3af; margin-top:40px; font-size: 0.85rem;">è¯·å…ˆåŠ è½½æ¨¡å‹</div>
                        </div>
                    </div>

                    <button class="btn btn-primary" id="quantizeBtn" style="background-color: var(--warning); border-color: var(--warning);" disabled>æ‰§è¡Œé‡åŒ–</button>
                </div>
            </div>
        </div>

        <!-- CENTER: Vis -->
        <div class="panel-center">
            <div id="graphContainer" style="flex: 2; min-height: 0;">
                <div id="graphPlaceholder" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #9ca3af;">
                    <h3 style="margin-bottom: 0.5rem; font-size: 1rem; font-weight: 500;">æ¨¡å‹ç»“æ„å¯è§†åŒ–</h3>
                    <p style="font-size: 0.875rem;">ä¸Šä¼  ONNX æ¨¡å‹ä»¥æŸ¥çœ‹å›¾ç»“æ„</p>
                </div>
                <canvas id="graphCanvas" style="display: none;"></canvas>
                <div class="graph-controls" id="graphControls" style="display: none;">
                    <button id="btnToggleLines" title="åˆ‡æ¢è¿çº¿æ˜¾ç¤º">âš¡</button>
                    <button id="btnZoomIn" title="æ”¾å¤§">+</button>
                    <button id="btnZoomOut" title="ç¼©å°">âˆ’</button>
                    <button id="btnZoomFit" title="é€‚åº”çª—å£">âŠ¡</button>
                    <button id="btnZoomReset" title="é‡ç½®">âŸ²</button>
                </div>
            </div>
            
            <div class="section" style="flex: 1; min-height: 200px; display:flex; flex-direction:column; background: white; border: 1px solid #e5e7eb; border-radius: var(--rounded-lg); overflow: hidden; padding: 0;">
                 <div class="section-title" style="padding: 0.75rem 1rem; background: #f9fafb; border-bottom: 1px solid #e5e7eb; margin: 0;">Python è¾“å‡º (stdout/stderr)</div>
                 <textarea id="pythonLog" style="flex:1; width:100%; border:none; resize:none; padding:1rem; font-family: ui-monospace, monospace; font-size: 0.75rem; color: #374151; background: #fff; line-height:1.5;" readonly placeholder="è½¬æ¢è¯¦æƒ…å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
            </div>
        </div>

        <!-- RIGHT: Logs & Results -->
        <div class="panel panel-right">
             <div class="section">
                 <div class="section-title">è½¬æ¢ç»“æœ</div>
                 <div id="resultsArea" class="hidden">
                    <div class="stat-card">
                        <div class="stat-row">
                             <span>åŸå§‹å¤§å°</span>
                             <span class="stat-val" id="resOrig">-</span>
                        </div>
                        <div class="stat-row">
                             <span>è½¬æ¢åå¤§å°</span>
                             <span class="stat-val" id="resNew">-</span>
                        </div>
                         <div class="stat-row">
                             <span>è½¬æ¢è€—æ—¶</span>
                             <span class="stat-val" id="resTime">-</span>
                        </div>
                         <div class="stat-row" id="inferenceTimeRow" style="display: none;">
                             <span>æ¨ç†è€—æ—¶ï¼ˆå¹³å‡ï¼‰</span>
                             <span class="stat-val" id="resInferenceTime">-</span>
                        </div>
                    </div>
                    
                    <div id="accuracyCard" class="stat-card hidden" style="background: #eff6ff; border-color: #bfdbfe;">
                        <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem; font-size: 0.85rem;">ç²¾åº¦å¯¹æ¯” (ONNX vs TFLite)</div>
                        <div class="stat-row" style="margin-bottom: 0.375rem;">
                             <span>æµ‹è¯•æ ·æœ¬æ•°</span>
                             <span class="stat-val" id="accSamples">-</span>
                        </div>
                        <div id="accuracyOutputs" style="font-size: 0.75rem; color: #374151;">
                            <!-- Per-output metrics will be inserted here -->
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" id="dlTflite" style="background-color: var(--success);">
                        <span>ä¸‹è½½ .tflite æ¨¡å‹</span>
                    </button>
                    <button class="btn btn-secondary" id="dlCpp">è½¬æ¢ä¸º C++å¤´æ–‡ä»¶ (.cc)</button>
                    <button class="btn btn-secondary" id="dlOnnxQ" class="hidden">ä¸‹è½½é‡åŒ–å ONNX</button>
                 </div>
                 <div id="noResults" style="text-align: center; color: #9ca3af; padding: 3rem 1rem; font-size: 0.875rem;">
                     ç­‰å¾…ä»»åŠ¡æ‰§è¡Œ...
                 </div>
             </div>

             <div class="section" style="flex: 1; display:flex; flex-direction:column; border-bottom: none; min-height: 15rem; padding:0;">
                 <div class="section-title" style="padding: 1rem 1rem 0 1rem;">ç³»ç»Ÿæ—¥å¿—</div>
                 <div class="console" id="console" style="flex:1; border-top: 1px solid #374151;"></div>
             </div>
             

        </div>
    </main>

    <script>
        // Simplified graph layout implementation
        window.dagre = {
            Graph: function(options) {
                this._nodes = {};
                this._edges = [];
                this._graph = {};
                this._nodeEdgeLabel = () => ({});
                
                this.setGraph = function(opts) {
                    this._graph = opts || {};
                    return this;
                };
                
                this.graph = function() {
                    return this._graph;
                };
                
                this.setDefaultEdgeLabel = function(fn) {
                    this._nodeEdgeLabel = fn;
                    return this;
                };
                
                this.setNode = function(id, data) {
                    this._nodes[id] = data || {};
                    return this;
                };
                
                this.node = function(id) {
                    return this._nodes[id];
                };
                
                this.nodes = function() {
                    return Object.keys(this._nodes);
                };
                
                this.setEdge = function(from, to, label) {
                    this._edges.push({ v: from, w: to, label: label || this._nodeEdgeLabel() });
                    return this;
                };
                
                this.edge = function(edgeObj) {
                    const found = this._edges.find(e => e.v === edgeObj.v && e.w === edgeObj.w);
                    return found ? found.label : undefined;
                };
                
                this.edges = function() {
                    return this._edges;
                };
            },
            
            layout: function(g) {
                const opts = g.graph() || {};
                const ranksep = opts.ranksep || 100;
                const nodesep = opts.nodesep || 80;
                
                // Build adjacency
                const inDegree = {};
                const outEdges = {};
                const layers = {};
                
                g.nodes().forEach(id => {
                    inDegree[id] = 0;
                    outEdges[id] = [];
                    layers[id] = 0;
                });
                
                g.edges().forEach(edge => {
                    outEdges[edge.v].push(edge.w);
                    inDegree[edge.w]++;
                });
                
                // Topological sort for layering
                const queue = [];
                g.nodes().forEach(id => {
                    if (inDegree[id] === 0) queue.push(id);
                });
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    outEdges[current].forEach(next => {
                        layers[next] = Math.max(layers[next], layers[current] + 1);
                        inDegree[next]--;
                        if (inDegree[next] === 0) queue.push(next);
                    });
                }
                
                // Group by layer
                const layerGroups = {};
                g.nodes().forEach(id => {
                    const layer = layers[id];
                    if (!layerGroups[layer]) layerGroups[layer] = [];
                    layerGroups[layer].push(id);
                });
                
                    // Position nodes
                    const layerWidths = {};
                    const startX = 0;
                    
                    Object.keys(layerGroups).forEach(layerIdx => {
                        const layerNodes = layerGroups[layerIdx];
                        const y = parseInt(layerIdx) * ranksep + 100;
                        let x = startX;
                        
                        layerNodes.forEach(nodeId => {
                            const node = g.node(nodeId);
                            // Store center position but render from top-left logic later
                            node.x = x + node.width / 2;
                            node.y = y;
                            x += node.width + nodesep;
                        });
                        layerWidths[layerIdx] = x;
                    });
                    
                    // Create edge paths with routing to avoid nodes
                    g.edges().forEach(edge => {
                        const from = g.node(edge.v);
                        const to = g.node(edge.w);
                        const fromLayer = layers[edge.v];
                        const toLayer = layers[edge.w];
                        
                        if (!from || !to) return;
                        
                        // Basic start and end points
                        const startPoint = { x: from.x, y: from.y + from.height / 2 };
                        const endPoint = { x: to.x, y: to.y - to.height / 2 };
                        
                        let points = [startPoint];
                        
                        // If edge spans multiple layers (skip connection), add intermediate points
                        if (toLayer > fromLayer + 1) {
                             // Find max width of intermediate layers to route around
                             let maxIntermediateX = 0;
                             for (let l = fromLayer + 1; l < toLayer; l++) {
                                 if (layerWidths[l]) {
                                     maxIntermediateX = Math.max(maxIntermediateX, layerWidths[l]);
                                 }
                             }
                             
                             // Add a buffer, varied slightly based on edge index to avoid overlap if multiple long edges exist
                             // Simple hash of node IDs to vary offset
                             const hash = (nodeId) => {
                                 let h = 0;
                                 for (let i = 0; i < nodeId.length; i++) h = ((h << 5) - h) + nodeId.charCodeAt(i) | 0;
                                 return Math.abs(h);
                             };
                             
                             const offsetVar = (hash(edge.v + edge.w) % 40); 
                             const detourX = maxIntermediateX + 60 + offsetVar;
                             
                             // Add points for the detour
                             // Adjust control points to create a smoother "C" curve
                             points.push({ x: detourX, y: startPoint.y + 20 }); 
                             points.push({ x: detourX, y: endPoint.y - 20 });
                        }
                        
                        points.push(endPoint);
                        
                        if (edge.label) {
                            edge.label.points = points;
                        }
                    });
                }
            };
        
        // --- Logic ---
        const ui = {
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            convertBtn: document.getElementById('convertBtn'),
            quantizeBtn: document.getElementById('quantizeBtn'),
            console: document.getElementById('console'),
            layerList: document.getElementById('layerList'),
            quantPanel: document.getElementById('quantPanel'),
            resultsArea: document.getElementById('resultsArea'),
            noResults: document.getElementById('noResults')
        };

        const state = {
            filename: null,
            modelInfo: null,
            tfliteFilename: null,
            calibFilename: null,
            layerTypes: [],
            isQuantizing: false
        };

        function log(msg, type='info') {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            div.className = `log-${type}`;
            ui.console.appendChild(div);
            // Auto-scroll logic could be added here
            ui.console.scrollTop = ui.console.scrollHeight;
            document.getElementById('statusText').textContent = type === 'error' ? 'é”™è¯¯' : (type === 'success' ? 'å°±ç»ª' : 'å¤„ç†ä¸­...');
        }

        // --- Event Listeners ---
        
        // Drag & Drop
        ui.dropZone.onclick = () => ui.fileInput.click();
        ui.dropZone.ondragover = (e) => { e.preventDefault(); ui.dropZone.classList.add('active'); };
        ui.dropZone.ondragleave = () => ui.dropZone.classList.remove('active');
        ui.dropZone.ondrop = (e) => {
            e.preventDefault();
            ui.dropZone.classList.remove('active');
            handleUpload(e.dataTransfer.files[0]);
        };
        ui.fileInput.onchange = (e) => handleUpload(e.target.files[0]);

        // Default Dims Toggle
        document.getElementById('defaultDims').onchange = (e) => {
            const el = document.getElementById('symbolicDims');
            if(e.target.checked) {
                 el.value = "batch_size=1,sequence_length=50";
            } else {
                 if(el.value === "batch_size=1,sequence_length=50") el.value = "";
            }
        };

        // Calibration Upload
        document.getElementById('uploadCalibBtn').onclick = () => document.getElementById('calibInput').click();
        document.getElementById('calibInput').onchange = async (e) => {
            if(!e.target.files[0]) return;
            const fd = new FormData();
            fd.append('file', e.target.files[0]);
            log('æ­£åœ¨ä¸Šä¼ æ ¡å‡†æ•°æ®...', 'info');
            try {
                const res = await fetch('/upload_calibration', { method: 'POST', body: fd });
                const d = await res.json();
                if(d.success) {
                    state.calibFilename = d.filename;
                    document.getElementById('calibInfo').textContent = `å·²åŠ è½½: ${d.file_count} ä¸ª .npy æ–‡ä»¶`;
                    log(`æ ¡å‡†æ•°æ®åŠ è½½æˆåŠŸ: ${d.file_count} ä¸ªæ ·æœ¬`, 'success');
                } else {
                    log(d.error, 'error');
                }
            } catch(e) {
                log('ä¸Šä¼ å¤±è´¥', 'error');
            }
        };

        async function handleUpload(file) {
            if(!file || !file.name.endsWith('.onnx')) return log('ä»…æ”¯æŒ .onnx æ–‡ä»¶', 'error');
            
            const fd = new FormData();
            fd.append('file', file);
            log(`æ­£åœ¨ä¸Šä¼  ${file.name}...`, 'info');
            
            try {
                const res = await fetch('/upload', { method: 'POST', body: fd });
                const d = await res.json();
                if(d.success) {
                    state.filename = d.filename;
                    state.modelInfo = d.model_info;
                    document.getElementById('fileName').textContent = file.name;
                    ui.convertBtn.disabled = false;
                    ui.quantizeBtn.disabled = false;
                    log('æ¨¡å‹ä¸Šä¼ æˆåŠŸã€‚', 'success');
                    renderModel(d.model_info);
                } else {
                    log(d.error, 'error');
                }
            } catch(e) {
                log('ä¸Šä¼ é”™è¯¯', 'error');
            }
        }

        function renderModel(info) {
            // Populate Layer List for Quantization
            state.layerTypes = Object.keys(info.node_types).sort();
            
            ui.layerList.innerHTML = state.layerTypes.map(t => {
                return `<label class="op-item"><input type="checkbox" value="${t}" checked> ${t}</label>`;
            }).join('');

            // Render Graph Visualization
            renderGraphVisualization(info);
        }
        
        // ========== Graph Visualization Engine ==========
        
        const graphState = {
            scale: 1,
            translateX: 0,
            translateY: 0,
            isDragging: false,
            startX: 0,
            startY: 0,
            showLines: true,  // Default: show lines
            layout: null,
            canvas: null,
            ctx: null
        };

        const EDGE_OFFSET = 10;
        const EDGE_DETACH = 16;
        const EDGE_COLORS = ['#2563eb', '#059669', '#d97706', '#db2777', '#9333ea', '#0f766e', '#22d3ee', '#f43f5e'];
        const NODE_HEADER_HEIGHT = 22;
        const DEFAULT_NODE_STYLE = {
            header: '#475569',
            body: '#f8fafc',
            border: '#1f2937',
            headerText: '#ffffff',
            bodyText: '#1f2937'
        };
        const INPUT_NODE_STYLE = {
            header: '#0ea5e9',
            body: '#ecfeff',
            border: '#0ea5e9',
            headerText: '#ffffff',
            bodyText: '#0369a1'
        };
        const OUTPUT_NODE_STYLE = {
            header: '#22c55e',
            body: '#ecfdf5',
            border: '#16a34a',
            headerText: '#ffffff',
            bodyText: '#065f46'
        };
        const NODE_STYLE_PRESETS = [
            { keywords: ['softmax'], header: '#b91c1c', body: '#fef2f2', border: '#991b1b', headerText: '#ffffff', bodyText: '#7f1d1d' },
            { keywords: ['conv', 'gemm'], header: '#1d4ed8', body: '#eff6ff', border: '#1e40af', headerText: '#ffffff', bodyText: '#1e3a8a' },
            { keywords: ['matmul'], header: '#0f172a', body: '#f3f4f6', border: '#0f172a', headerText: '#f8fafc', bodyText: '#111827' },
            { keywords: ['add', 'mul', 'sub', 'div', 'pow'], header: '#111827', body: '#f1f5f9', border: '#0f172a', headerText: '#f8fafc', bodyText: '#111827' },
            { keywords: ['relu', 'sigmoid', 'tanh', 'gelu', 'leakyrelu', 'elu'], header: '#92400e', body: '#fff7ed', border: '#78350f', headerText: '#fff7ed', bodyText: '#78350f' },
            { keywords: ['reshape', 'transpose', 'squeeze', 'unsqueeze', 'flatten', 'view'], header: '#7c3aed', body: '#f5f3ff', border: '#6d28d9', headerText: '#ffffff', bodyText: '#4c1d95' },
            { keywords: ['gather', 'slice', 'concat', 'pad', 'split'], header: '#047857', body: '#ecfdf5', border: '#065f46', headerText: '#ecfdf5', bodyText: '#064e3b' },
            { keywords: ['reduce', 'mean', 'sum', 'pool'], header: '#0f766e', body: '#ecfeff', border: '#0d9488', headerText: '#ecfeff', bodyText: '#115e59' }
        ];
        
        function renderGraphVisualization(info) {
            if (!info.nodes || !info.edges) {
                console.warn('No graph structure data available');
                return;
            }
            
            document.getElementById('graphPlaceholder').style.display = 'none';
            const canvas = document.getElementById('graphCanvas');
            canvas.style.display = 'block';
            document.getElementById('graphControls').style.display = 'flex';
            
            // Setup canvas
            graphState.canvas = canvas;
            graphState.ctx = canvas.getContext('2d');
            resizeCanvas();
            
            // Calculate layout
            graphState.layout = calculateGraphLayout(info);
            
            // Render to Canvas
            renderToCanvas();
            
            // Set initial button state for toggle lines
            const btnToggle = document.getElementById('btnToggleLines');
            if (graphState.showLines) {
                btnToggle.classList.add('active');
            } else {
                btnToggle.classList.remove('active');
            }
            
            // Reset view to fit
            setTimeout(() => fitToView(), 100);
        }
        
        function resizeCanvas() {
            const container = document.getElementById('graphContainer');
            const canvas = graphState.canvas;
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            
            graphState.ctx.scale(dpr, dpr);
            
            if (graphState.layout) {
                renderToCanvas();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        function calculateGraphLayout(info) {
            const nodeWidth = 180;
            const nodeHeight = 50;  // æ›´æ‰çš„èŠ‚ç‚¹
            
            // åˆ›å»º dagre å›¾å¯¹è±¡
            const g = new dagre.Graph({
                directed: true,
                multigraph: false,
                compound: false
            });
            
            // è®¾ç½®å›¾çš„å…¨å±€å±æ€§
            g.setGraph({
                rankdir: 'TB',  // Top to Bottom
                nodesep: 80,    // èŠ‚ç‚¹é—´æ°´å¹³é—´è·
                ranksep: 100,    // å±‚çº§é—´å‚ç›´é—´è·
                marginx: 40,
                marginy: 40
            });
            
            g.setDefaultEdgeLabel(() => ({}));
            
            // Build node map
            const nodeMap = new Map();
            
            // Add input nodes
            info.inputs.forEach(inp => {
                const id = `input_${inp.name}`;
                const node = { id, type: 'input', label: inp.name, shape: inp.shape };
                nodeMap.set(id, node);
                g.setNode(id, { width: nodeWidth, height: nodeHeight, node });
            });
            
            // Add operation nodes
            info.nodes.forEach(node => {
                const fullNode = { ...node, label: node.name, type: 'op' };
                nodeMap.set(node.id, fullNode);
                g.setNode(node.id, { width: nodeWidth, height: nodeHeight, node: fullNode });
            });
            
            // Add output nodes
            info.outputs.forEach(out => {
                const id = `output_${out.name}`;
                const node = { id, type: 'output', label: out.name, shape: out.shape };
                nodeMap.set(id, node);
                g.setNode(id, { width: nodeWidth, height: nodeHeight, node });
            });
            
            // Build edge connections
            info.edges.forEach(edge => {
                if (nodeMap.has(edge.from) && nodeMap.has(edge.to)) {
                    g.setEdge(edge.from, edge.to, { edge });
                }
            });
            
            // ä½¿ç”¨ dagre è®¡ç®—å¸ƒå±€
            dagre.layout(g);
            
            // æå–è®¡ç®—åçš„ä½ç½®
            const positions = new Map();
            g.nodes().forEach(nodeId => {
                const dagreNode = g.node(nodeId);
                const node = dagreNode.node;
                // dagre è¿”å›çš„æ˜¯ä¸­å¿ƒç‚¹åæ ‡ï¼Œè½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡
                positions.set(nodeId, {
                    x: dagreNode.x - nodeWidth / 2,
                    y: dagreNode.y - nodeHeight / 2,
                    width: nodeWidth,
                    height: nodeHeight,
                    node
                });
            });
            
            // æå–è¾¹çš„è·¯å¾„ç‚¹
            const edgePoints = new Map();
            g.edges().forEach(edgeObj => {
                const edge = g.edge(edgeObj);
                if (edge && edge.points) {
                    const key = `${edgeObj.v}-${edgeObj.w}`;
                    edgePoints.set(key, edge.points || []);
                }
            });

            const bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            positions.forEach(pos => {
                bounds.minX = Math.min(bounds.minX, pos.x);
                bounds.minY = Math.min(bounds.minY, pos.y);
                bounds.maxX = Math.max(bounds.maxX, pos.x + pos.width);
                bounds.maxY = Math.max(bounds.maxY, pos.y + pos.height);
            });

            return { positions, edges: info.edges, nodeMap, tensorShapes: buildTensorShapeMap(info), bounds, edgePoints };
        }
        
        function buildTensorShapeMap(info) {
            const shapeMap = new Map();
            
            // Use tensor_shapes from backend if available
            if (info.tensor_shapes) {
                for (const [tensorName, shape] of Object.entries(info.tensor_shapes)) {
                    shapeMap.set(tensorName, shape);
                }
            }
            
            // Map input shapes
            info.inputs.forEach(inp => {
                if (!shapeMap.has(inp.name)) {
                    shapeMap.set(inp.name, inp.shape);
                }
            });
            
            // Map output shapes
            info.outputs.forEach(out => {
                if (!shapeMap.has(out.name)) {
                    shapeMap.set(out.name, out.shape);
                }
            });
            
            return shapeMap;
        }
        
        function renderToCanvas() {
            const ctx = graphState.ctx;
            const canvas = graphState.canvas;
            const layout = graphState.layout;
            
            if (!ctx || !layout) return;
            
            // Clear canvas
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply transformations
            ctx.translate(graphState.translateX, graphState.translateY);
            ctx.scale(graphState.scale, graphState.scale);
            
            // Draw edges first (behind nodes) if enabled
            if (graphState.showLines) {
                layout.edges.forEach((edge, idx) => drawDagreEdge(ctx, layout, edge, idx));
            }
            
            // Draw nodes
            layout.positions.forEach(pos => {
                const x = pos.x;
                const y = pos.y;
                const w = pos.width;
                const h = pos.height;
                const node = pos.node;
                const style = getNodeStyle(node);

                // Card shadow
                ctx.shadowColor = 'rgba(15, 23, 42, 0.18)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 3;

                roundRect(ctx, x, y, w, h, 10);
                ctx.fillStyle = style.body;
                ctx.fill();

                ctx.shadowColor = 'transparent';
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = style.border;
                ctx.stroke();

                // Header strip
                ctx.fillStyle = style.header;
                ctx.beginPath();
                // Top-left corner (rounded)
                ctx.moveTo(x, y + NODE_HEADER_HEIGHT);
                ctx.lineTo(x, y + 10); // 10 is radius
                ctx.arcTo(x, y, x + 10, y, 10);
                
                // Top edge
                ctx.lineTo(x + w - 10, y);
                
                // Top-right corner (rounded)
                ctx.arcTo(x + w, y, x + w, y + 10, 10);
                
                // Right edge down to header height
                ctx.lineTo(x + w, y + NODE_HEADER_HEIGHT);
                
                // Bottom edge of header
                ctx.lineTo(x, y + NODE_HEADER_HEIGHT);
                
                ctx.closePath();
                ctx.fill();

                // Header text
                ctx.fillStyle = style.headerText;
                ctx.font = 'bold 11px "Segoe UI", system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const headerLabel = truncateText(getNodeHeaderLabel(node), 18);
                ctx.fillText(headerLabel, x + w / 2, y + NODE_HEADER_HEIGHT / 2 + 1);

                // Body text
                ctx.fillStyle = style.bodyText;
                ctx.font = '10px "Segoe UI", system-ui, sans-serif';
                const primaryLabel = truncateText(getNodeBodyLabel(node), 22);
                ctx.fillText(primaryLabel, x + w / 2, y + NODE_HEADER_HEIGHT + 12);

                const shapeText = getNodeShapeLabel(node, layout.tensorShapes);
                if (shapeText) {
                    ctx.fillStyle = style.bodyText;
                    ctx.font = '9px ui-monospace, monospace';
                    ctx.fillText(shapeText, x + w / 2, y + h - 10);
                }

                // Additional input shape hint
                if (node.type === 'op' && node.inputs && node.inputs.length > 0) {
                    const inputShape = getInputShape(node, layout.tensorShapes);
                    if (inputShape) {
                        ctx.fillStyle = '#059669';
                        ctx.font = '9px ui-monospace, monospace';
                        const shapeLabel = 'In: ' + formatShape(inputShape);
                        ctx.fillText(truncateText(shapeLabel, 28), x + w / 2, y + h - 24);
                    }
                }

                ctx.shadowColor = 'transparent';
            });
            
            ctx.restore();
        }

        function drawDagreEdge(ctx, layout, edge, idx) {
            const fromPos = layout.positions.get(edge.from);
            const toPos = layout.positions.get(edge.to);
            if (!fromPos || !toPos) return;

            const key = `${edge.from}-${edge.to}`;
            let points = layout.edgePoints && layout.edgePoints.get(key);
            
            // å¦‚æœ dagre æ²¡æœ‰æä¾›è·¯å¾„ç‚¹ï¼Œä½¿ç”¨é»˜è®¤ç›´çº¿
            if (!points || points.length === 0) {
                const fromCenter = { x: fromPos.x + fromPos.width / 2, y: fromPos.y + fromPos.height };
                const toCenter = { x: toPos.x + toPos.width / 2, y: toPos.y };
                points = [fromCenter, toCenter];
            }

            // ç»˜åˆ¶å¹³æ»‘æ›²çº¿
            const color = EDGE_COLORS[idx % EDGE_COLORS.length];
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            if (points.length === 2) {
                // ç›´çº¿ï¼šä½¿ç”¨ç®€å•çš„æ›²çº¿
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                const midY = (points[0].y + points[1].y) / 2;
                ctx.bezierCurveTo(
                    points[0].x, midY,
                    points[1].x, midY,
                    points[1].x, points[1].y
                );
                ctx.stroke();
            } else {
                // å¤šç‚¹è·¯å¾„ï¼šç»˜åˆ¶å¹³æ»‘æ›²çº¿
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                // å¦‚æœæ˜¯ç®€å•çš„ç»•è¡Œè·¯å¾„ï¼ˆ4ä¸ªç‚¹ï¼šèµ·ç‚¹ï¼ŒæŠ˜ç‚¹1ï¼ŒæŠ˜ç‚¹2ï¼Œç»ˆç‚¹ï¼‰ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸‰æ¬¡è´å¡å°”æ›²çº¿
                if (points.length === 4) {
                     ctx.bezierCurveTo(
                        points[1].x, points[1].y,
                        points[2].x, points[2].y,
                        points[3].x, points[3].y
                    );
                } else {
                    for (let i = 1; i < points.length - 1; i++) {
                        const xc = (points[i].x + points[i + 1].x) / 2;
                        const yc = (points[i].y + points[i + 1].y) / 2;
                        ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                    }
                    ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
                }
                ctx.stroke();
            }

            // ç»˜åˆ¶ç®­å¤´
            const lastFrom = points[points.length - 2];
            const lastTo = points[points.length - 1];
            drawArrowHead(ctx, lastFrom, lastTo, color);
        }

        function drawArrowHead(ctx, from, to, color) {
            if (!from || !to) return;
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const size = 8;
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(
                to.x - size * Math.cos(angle - Math.PI / 6),
                to.y - size * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                to.x - size * Math.cos(angle + Math.PI / 6),
                to.y - size * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        function getEdgeColor(edge) {
            const key = `${edge.from}->${edge.to}`;
            const idx = Math.abs(hashString(key)) % EDGE_COLORS.length;
            return EDGE_COLORS[idx];
        }

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return hash;
        }
        
        // Helper function to get input shape
        function getInputShape(node, tensorShapes) {
            if (!node.inputs || node.inputs.length === 0) return null;
            
            // Get the first input tensor's shape
            const firstInput = node.inputs[0];
            if (tensorShapes && tensorShapes.has(firstInput)) {
                return tensorShapes.get(firstInput);
            }
            
            return null;
        }
        
        // Helper function to format shape array
        function formatShape(shape) {
            if (!shape || shape.length === 0) return '?';
            return '[' + shape.map(dim => {
                if (typeof dim === 'string') return dim;
                if (typeof dim === 'number') return dim;
                return '?';
            }).join(',') + ']';
        }

        function getNodeStyle(node) {
            if (node.type === 'input') return INPUT_NODE_STYLE;
            if (node.type === 'output') return OUTPUT_NODE_STYLE;

            const op = (node.op_type || '').toLowerCase();
            for (const preset of NODE_STYLE_PRESETS) {
                if (preset.keywords.some(keyword => op.includes(keyword))) {
                    return preset;
                }
            }
            return DEFAULT_NODE_STYLE;
        }

        function getNodeHeaderLabel(node) {
            if (node.type === 'input') return 'Input';
            if (node.type === 'output') return 'Output';
            return node.op_type || node.label || node.id;
        }

        function getNodeBodyLabel(node) {
            if (node.type === 'input' || node.type === 'output') {
                return node.label || node.id;
            }
            if (node.label && node.label !== node.op_type) {
                return node.label;
            }
            return node.id || '';
        }

        function getNodeShapeLabel(node, tensorShapes) {
            if (node.shape && (node.type === 'input' || node.type === 'output')) {
                return formatShape(node.shape);
            }

            const outputs = node.outputs || [];
            for (const out of outputs) {
                if (tensorShapes && tensorShapes.has(out)) {
                    return formatShape(tensorShapes.get(out));
                }
            }
            return '';
        }

        function truncateText(text, max = 20) {
            if (!text) return '';
            return text.length > max ? text.substring(0, max - 3) + '...' : text;
        }
        
        // Helper function to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }
        
        function updateTransform() {
            renderToCanvas();
        }
        
        function fitToView() {
            if (!graphState.layout) return;
            
            const layout = graphState.layout;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            layout.positions.forEach(pos => {
                minX = Math.min(minX, pos.x);
                minY = Math.min(minY, pos.y);
                maxX = Math.max(maxX, pos.x + pos.width);
                maxY = Math.max(maxY, pos.y + pos.height);
            });
            
            const bbox = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
            
            if (bbox.width === 0 || bbox.height === 0) return;
            
            const container = document.getElementById('graphContainer');
            const padding = 50;
            const scaleX = (container.clientWidth - padding * 2) / bbox.width;
            const scaleY = (container.clientHeight - padding * 2) / bbox.height;
            const scale = Math.min(scaleX, scaleY, 1);
            
            graphState.scale = scale;
            graphState.translateX = (container.clientWidth - bbox.width * scale) / 2 - bbox.x * scale;
            graphState.translateY = (container.clientHeight - bbox.height * scale) / 2 - bbox.y * scale;
            
            updateTransform();
        }
        
        // ========== Graph Controls ==========
        
        document.getElementById('btnToggleLines').onclick = () => {
            graphState.showLines = !graphState.showLines;
            const btn = document.getElementById('btnToggleLines');
            if (graphState.showLines) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            renderToCanvas();
        };
        
        document.getElementById('btnZoomIn').onclick = () => {
            // Zoom towards center of canvas
            const container = document.getElementById('graphContainer');
            const centerX = container.clientWidth / 2;
            const centerY = container.clientHeight / 2;
            zoomAtPoint(centerX, centerY, 1.2);
        };
        
        document.getElementById('btnZoomOut').onclick = () => {
            // Zoom towards center of canvas
            const container = document.getElementById('graphContainer');
            const centerX = container.clientWidth / 2;
            const centerY = container.clientHeight / 2;
            zoomAtPoint(centerX, centerY, 1 / 1.2);
        };
        
        document.getElementById('btnZoomFit').onclick = fitToView;
        
        document.getElementById('btnZoomReset').onclick = () => {
            graphState.scale = 1;
            graphState.translateX = 0;
            graphState.translateY = 0;
            updateTransform();
        };
        
        // Panning with mouse drag
        const graphContainer = document.getElementById('graphContainer');
        
        graphContainer.addEventListener('mousedown', (e) => {
            if (e.target === graphContainer || e.target.id === 'graphCanvas') {
                graphState.isDragging = true;
                graphState.startX = e.clientX - graphState.translateX;
                graphState.startY = e.clientY - graphState.translateY;
                graphContainer.classList.add('grabbing');
            }
        });
        
        graphContainer.addEventListener('mousemove', (e) => {
            if (graphState.isDragging) {
                graphState.translateX = e.clientX - graphState.startX;
                graphState.translateY = e.clientY - graphState.startY;
                updateTransform();
            }
        });
        
        graphContainer.addEventListener('mouseup', () => {
            graphState.isDragging = false;
            graphContainer.classList.remove('grabbing');
        });
        
        graphContainer.addEventListener('mouseleave', () => {
            graphState.isDragging = false;
            graphContainer.classList.remove('grabbing');
        });
        
        // Zoom with mouse wheel
        graphContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // Get mouse position relative to canvas
            const rect = graphContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom factor
            const delta = e.deltaY > 0 ? 1 / 1.1 : 1.1;
            
            // Zoom at mouse position
            zoomAtPoint(mouseX, mouseY, delta);
        });
        
        function zoomAtPoint(clientX, clientY, scaleFactor) {
            // Calculate world coordinates before zoom
            const worldX = (clientX - graphState.translateX) / graphState.scale;
            const worldY = (clientY - graphState.translateY) / graphState.scale;
            
            // Apply scale
            graphState.scale *= scaleFactor;
            
            // Calculate new translation to keep the same world point under the mouse
            graphState.translateX = clientX - worldX * graphState.scale;
            graphState.translateY = clientY - worldY * graphState.scale;
            
            updateTransform();
        }

        function getSettings() {
            return {
                allowInputsStripping: document.getElementById('allowInputsStripping').checked,
                keepIoFormat: document.getElementById('keepIoFormat').checked,
                skipShapeInference: document.getElementById('skipShapeInference').checked,
                allowSelectOps: document.getElementById('allowSelectOps').checked,
                castInt64ToInt32: document.getElementById('castInt64ToInt32').checked,
                symbolicDims: document.getElementById('symbolicDims').value,
                perChannel: document.getElementById('perChannel').checked,
                allowOpset10: document.getElementById('allowOpset10').checked
            };
        }

        // Conversion
        ui.convertBtn.onclick = async () => {
            if(!state.filename) return;
            log('å¼€å§‹æ ‡å‡†è½¬æ¢ä»»åŠ¡...', 'info');
            document.getElementById('pythonLog').value = "æ­£åœ¨è¿è¡Œ...";
            ui.convertBtn.disabled = true;
            
            try {
                const res = await fetch('/convert', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        filename: state.filename,
                        settings: getSettings()
                    })
                });
                const d = await res.json();
                if(d.logs) document.getElementById('pythonLog').value = d.logs;
                
                if(d.success) {
                    showResults(d);
                    log('è½¬æ¢å®Œæˆ!', 'success');
                } else {
                    log('é”™è¯¯: ' + d.error, 'error');
                }
            } catch(e) { log('ç½‘ç»œ/æœåŠ¡å™¨é”™è¯¯', 'error'); }
            finally { ui.convertBtn.disabled = false; }
        };

        // Quantization
        ui.quantizeBtn.onclick = async () => {
             if(!state.filename) return;
             
             // Get selected layers
             const selected = Array.from(ui.layerList.querySelectorAll('input:checked')).map(cb => cb.value);
             if(selected.length === 0) return log('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§é‡åŒ–å±‚ç±»å‹!', 'error');

             log('å¼€å§‹é‡åŒ–åŠè½¬æ¢ä»»åŠ¡...', 'info');
             document.getElementById('pythonLog').value = "æ­£åœ¨è¿è¡Œé‡åŒ–ä»»åŠ¡...";
             ui.quantizeBtn.disabled = true;
             
             try {
                const res = await fetch('/quantize', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        filename: state.filename,
                        settings: getSettings(),
                        selectedLayers: selected,
                        calibFilename: state.calibFilename
                    })
                });
                const d = await res.json();
                if(d.logs) document.getElementById('pythonLog').value = d.logs;
                
                if(d.success) {
                    state.tfliteFilename = d.quantized_tflite_filename;
                    
                    ui.noResults.classList.add('hidden');
                    ui.resultsArea.classList.remove('hidden');
                    
                    // Display statistics
                    if(d.stats) {
                        document.getElementById('resOrig').textContent = (d.stats.original_size/1024).toFixed(2) + " KB";
                        document.getElementById('resNew').textContent = (d.stats.converted_size/1024).toFixed(2) + " KB";
                        document.getElementById('resTime').textContent = d.stats.time;
                        
                        // Show inference time if available
                        if(d.stats.inference_time) {
                            document.getElementById('resInferenceTime').textContent = d.stats.inference_time;
                            document.getElementById('inferenceTimeRow').style.display = 'flex';
                        } else {
                            document.getElementById('inferenceTimeRow').style.display = 'none';
                        }
                    }
                    
                    const btnQ = document.getElementById('dlOnnxQ');
                    btnQ.classList.remove('hidden');
                    btnQ.onclick = () => window.location.href = `/download/${d.quantized_onnx_filename}`;
                    
                    // Display accuracy comparison if available
                    if(d.accuracy) {
                        displayAccuracy(d.accuracy);
                    } else {
                        document.getElementById('accuracyCard').classList.add('hidden');
                    }

                    log('é‡åŒ–å®Œæˆ!', 'success');
                } else {
                    log('é”™è¯¯: ' + d.error, 'error');
                }
             } catch(e) { log('ç½‘ç»œé”™è¯¯', 'error'); }
             finally { ui.quantizeBtn.disabled = false; }
        };

        function showResults(data) {
            state.tfliteFilename = data.tflite_filename;
            
            // Only update results view if this was a successful run
            if(data.success) {
                ui.noResults.classList.add('hidden');
                document.getElementById('resultsArea').classList.remove('hidden');

                if(data.stats) {
                    document.getElementById('resOrig').textContent = (data.stats.original_size/1024).toFixed(2) + " KB";
                    document.getElementById('resNew').textContent = (data.stats.converted_size/1024).toFixed(2) + " KB";
                    document.getElementById('resTime').textContent = data.stats.time;
                    
                    // Show inference time if available
                    if(data.stats.inference_time) {
                        document.getElementById('resInferenceTime').textContent = data.stats.inference_time;
                        document.getElementById('inferenceTimeRow').style.display = 'flex';
                    } else {
                        document.getElementById('inferenceTimeRow').style.display = 'none';
                    }
                }
                
                // Hide quantized ONNX download button for regular conversion
                document.getElementById('dlOnnxQ').classList.add('hidden');
                
                // Display accuracy comparison if available
                if(data.accuracy) {
                    displayAccuracy(data.accuracy);
                } else {
                    document.getElementById('accuracyCard').classList.add('hidden');
                }
            } else {
                 if(data.error) log('è½¬æ¢å¤±è´¥: ' + data.error, 'error');
            }
        }

        function displayAccuracy(accuracy) {
            const card = document.getElementById('accuracyCard');
            const samplesEl = document.getElementById('accSamples');
            const outputsEl = document.getElementById('accuracyOutputs');
            
            card.classList.remove('hidden');
            samplesEl.textContent = accuracy.num_samples;
            
            // Clear previous outputs
            outputsEl.innerHTML = '';
            
            // Display each output's metrics
            accuracy.outputs.forEach((output, idx) => {
                const outputDiv = document.createElement('div');
                outputDiv.style.cssText = 'margin-top: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px; border: 1px solid #e5e7eb;';
                
                let outputName = output.output_name;
                if (outputName.length > 25) {
                    outputName = outputName.substring(0, 22) + '...';
                }
                
                outputDiv.innerHTML = `
                    <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.25rem;">${outputName}</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.25rem; font-size: 0.7rem;">
                        <div>MAE: <span style="font-family: monospace; font-weight: 600;">${output.mae.toExponential(3)}</span></div>
                        <div>RMSE: <span style="font-family: monospace; font-weight: 600;">${output.rmse.toExponential(3)}</span></div>
                        <div>ä½™å¼¦ç›¸ä¼¼åº¦: <span style="font-family: monospace; font-weight: 600;">${output.cosine_similarity.toFixed(6)}</span></div>
                        <div>æœ€å¤§è¯¯å·®: <span style="font-family: monospace; font-weight: 600;">${output.max_error.toExponential(3)}</span></div>
                    </div>
                `;
                
                outputsEl.appendChild(outputDiv);
            });
        }

        document.getElementById('dlTflite').onclick = () => {
            if(state.tfliteFilename) window.location.href = `/download/${state.tfliteFilename}`;
        };

        document.getElementById('dlCpp').onclick = async () => {
            if(!state.tfliteFilename) return;
            log('æ­£åœ¨ç”Ÿæˆ C++ æ•°ç»„...', 'info');
            const res = await fetch('/convert_to_cpp', {
                 method: 'POST', headers: {'Content-Type': 'application/json'},
                 body: JSON.stringify({filename: state.tfliteFilename})
            });
            const d = await res.json();
            if(d.success) window.location.href = `/download/${d.cpp_filename}`;
            else log('C++ è½¬æ¢å¤±è´¥', 'error');
        };

        // Select All / Clear All
        document.getElementById('btnSelectAll').onclick = () => {
            ui.layerList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        };
        document.getElementById('btnClearAll').onclick = () => {
            ui.layerList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        };

        // Download calibration data generator example
        document.getElementById('downloadExampleBtn').onclick = () => {
            if(!state.modelInfo) {
                log('è¯·å…ˆä¸Šä¼ æ¨¡å‹ä»¥è·å–è¾“å…¥ä¿¡æ¯', 'error');
                return;
            }
            window.location.href = '/download_calib_generator';
        };

    </script>
</body>
</html>
