<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNXè½¬TFLiteè½¬æ¢å™¨</title>
    <style>
        /* Tailwind-inspired System Font Stack & Colors */
        :root {
            /* Neutrals */
            --bg-body: #f3f4f6; /* gray-100 */
            --bg-white: #ffffff;
            --text-primary: #111827; /* gray-900 */
            --text-secondary: #4b5563; /* gray-600 */
            --border-color: #e5e7eb; /* gray-200 */
            
            /* Accents */
            --accent-blue: #3b82f6; /* blue-500 */
            --accent-hover: #2563eb; /* blue-600 */
            --success: #10b981; /* emerald-500 */
            --warning: #f59e0b; /* amber-500 */
            --danger: #ef4444; /* red-500 */
            
            /* Shadows & Radius */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --rounded: 0.375rem; /* 6px */
            --rounded-lg: 0.5rem; /* 8px */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        
        body { background: var(--bg-body); color: var(--text-primary); height: 100vh; display: flex; flex-direction: column; overflow: hidden; font-size: 0.875rem; /* 14px */ }

        /* Header */
        header {
            height: 56px; background: var(--bg-white); border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem;
            box-shadow: var(--shadow-sm); z-index: 50;
        }
        header h1 { font-size: 1.125rem; font-weight: 700; color: var(--text-primary); letter-spacing: -0.025em; }
        header .status { font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); background: #f3f4f6; padding: 0.25rem 0.75rem; border-radius: 9999px; }
        header .copyright { font-size: 0.7rem; color: #9ca3af; margin-right: 1rem; font-weight: 400; }

        /* Layout */
        main { flex: 1; display: grid; grid-template-columns: 280px 300px 1fr 450px; height: calc(100vh - 56px); }
        
        /* Panels */
        .panel { display: flex; flex-direction: column; overflow-y: auto; background: var(--bg-white); border-right: 1px solid var(--border-color); }
        .panel-center { background: #f9fafb; padding: 1.5rem; position: relative; border-right: 1px solid var(--border-color); overflow: hidden; display: flex; flex-direction: column; gap: 1rem; }
        .panel-right { border-left: none; } /* already handled by border-right of center if specific order, but keeping standard */

        /* Sections */
        .section { padding: 1.25rem; border-bottom: 1px solid var(--border-color); }
        .section-title { 
            font-size: 0.75rem; text-transform: uppercase; color: #6b7280; font-weight: 700; 
            margin-bottom: 0.75rem; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.5rem;
        }

        /* Forms & Inputs */
        .setting-group { margin-bottom: 1rem; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; padding: 0.375rem 0; font-size: 0.825rem; color: #374151; }
        .setting-row label { cursor: pointer; }

        input[type="checkbox"] { 
            appearance: none; background-color: #fff; margin: 0; font: inherit; color: currentColor;
            width: 1.15em; height: 1.15em; border: 1px solid #d1d5db; border-radius: 0.25rem;
            display: grid; place-content: center; cursor: pointer;
        }
        input[type="checkbox"]::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0); transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em white; transform-origin: center; clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        input[type="checkbox"]:checked { background-color: var(--accent-blue); border-color: var(--accent-blue); }
        input[type="checkbox"]:checked::before { transform: scale(1); }

        input[type="text"] {
            width: 100%; border: 1px solid #d1d5db; border-radius: var(--rounded); padding: 0.5rem 0.75rem;
            font-size: 0.875rem; margin-top: 0.25rem; transition: border-color 0.15s ease-in-out; outline: none;
        }
        input[type="text"]:focus { border-color: var(--accent-blue); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); }

        /* Buttons */
        .btn {
            display: inline-flex; justify-content: center; align-items: center; width: 100%;
            padding: 0.5rem 1rem; border: 1px solid transparent; border-radius: var(--rounded);
            font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.15s ease-in-out;
            margin-top: 0.75rem;
        }
        .btn-primary { background-color: var(--accent-blue); color: white; }
        .btn-primary:hover { background-color: var(--accent-hover); }
        .btn-primary:disabled { background-color: #9ca3af; cursor: not-allowed; }
        
        .btn-secondary { background-color: white; border-color: #d1d5db; color: #374151; }
        .btn-secondary:hover { background-color: #f9fafb; border-color: #9ca3af; }

        .upload-box {
            border: 2px dashed #e5e7eb; border-radius: var(--rounded-lg); padding: 2rem 1rem;
            text-align: center; cursor: pointer; transition: all 0.2s; background: #f9fafb; color: #6b7280;
        }
        .upload-box:hover { border-color: var(--accent-blue); color: var(--accent-blue); background: #eff6ff; }
        .upload-box.active { border-color: var(--accent-blue); background: #eff6ff; }

        /* Graph Card */
        #graphContainer { 
            background: white; border-radius: var(--rounded-lg); 
            box-shadow: var(--shadow-md); border: 1px solid #e5e7eb; 
            width: 100%; height: 100%; overflow: hidden; position: relative;
            cursor: grab;
        }
        #graphContainer.grabbing { cursor: grabbing; }
        
        /* Graph Canvas Styles */
        #graphCanvas { 
            width: 100%; 
            height: 100%; 
            display: block;
        }
        
        .graph-controls {
            position: absolute; top: 12px; right: 12px; display: flex; gap: 6px;
            background: white; padding: 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .graph-controls button {
            width: 28px; height: 28px; border: 1px solid #e5e7eb; background: white;
            border-radius: 4px; cursor: pointer; display: flex; align-items: center;
            justify-content: center; font-size: 14px; transition: all 0.15s;
        }
        .graph-controls button:hover { background: #f3f4f6; border-color: #3b82f6; }
        .graph-controls button.active { background: #3b82f6; color: white; border-color: #3b82f6; }

        /* Helpers */
        .hidden { display: none !important; }
        .badge { background: #e5e7eb; color: #374151; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; }

        /* List & Logs */
        .op-list { flex: 1; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: var(--rounded); padding: 0.5rem; }
        .op-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem; font-size: 0.85rem; color: #4b5563; }
        .op-item:hover { background: #f3f4f6; border-radius: 4px; }

        .console { background: #111827; color: #e5e7eb; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 0.75rem; padding: 1rem; overflow-y: auto; line-height: 1.5; }
        .log-info { color: #60a5fa; }
        .log-error { color: #f87171; }
        .log-success { color: #34d399; }

        .stat-card { background: #f9fafb; padding: 1rem; border-radius: var(--rounded); border: 1px solid #e5e7eb; margin-bottom: 0.5rem; }
        .stat-row { display: flex; justify-content: space-between; font-size: 0.85rem; color: #4b5563; margin-bottom: 0.25rem; }
        .stat-val { font-weight: 600; color: #111827; font-family: ui-monospace, monospace; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
    </style>
</head>
<body>
    <header>
        <h1>ONNX è½¬ TFLite è½¬æ¢å™¨ <span style="font-size:0.75em; color:#9ca3af; font-weight:400; margin-left:8px;">ä¸“ä¸šç‰ˆ</span></h1>
        <div style="display: flex; align-items: center;">
            <div class="copyright">Â© 2026 è¿œå³°ç§‘æŠ€ ç‰ˆæƒæ‰€æœ‰</div>
            <div class="status" id="statusText">å°±ç»ª</div>
        </div>
    </header>

    <main>
        <!-- LEFT: Controls -->
        <div class="panel">
            <!-- 1. Model Upload -->
            <div class="section">
                <div class="section-title">1. è¾“å…¥æ¨¡å‹</div>
                <div class="upload-box" id="dropZone">
                    <svg style="width:24px;height:24px;margin-bottom:8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                    <div style="font-size: 0.875rem; font-weight: 500;">æ‹–å…¥ ONNX æ¨¡å‹</div>
                    <div id="fileName" style="font-size: 0.75rem; margin-top: 4px; color: var(--accent-blue);"></div>
                </div>
                <input type="file" id="fileInput" hidden accept=".onnx">
            </div>

            <!-- 2. Converter Settings -->
            <div class="section">
                <div class="section-title">2. è½¬æ¢è®¾ç½®</div>
                
                <div class="setting-group">
                    <div class="setting-row">
                        <label>å…è®¸å‰¥ç¦»è¾“å…¥ (Strip Inputs)</label>
                        <input type="checkbox" id="allowInputsStripping">
                    </div>
                    <div class="setting-row">
                        <label>ä¿æŒ IO æ ¼å¼ (NCHW)</label>
                        <input type="checkbox" id="keepIoFormat">
                    </div>
                    <div class="setting-row">
                        <label>è·³è¿‡å½¢çŠ¶æ¨æ–­</label>
                        <input type="checkbox" id="skipShapeInference">
                    </div>
                     <div class="setting-row">
                        <label>å…è®¸ Select Ops (Flex)</label>
                        <input type="checkbox" id="allowSelectOps">
                    </div>
                     <div class="setting-row">
                        <label>å¼ºåˆ¶è½¬æ¢ Int64->32</label>
                        <input type="checkbox" id="castInt64ToInt32">
                    </div>
                </div>

                <div class="setting-group">
                    <div style="font-size: 0.75rem; font-weight: 700; color: #6b7280; margin-bottom: 0.5rem;">ç¬¦å·ç»´åº¦ (Symbolic Dims)</div>
                    <div style="margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                         <input type="checkbox" id="defaultDims">
                         <label for="defaultDims" style="font-size: 0.825rem; color: #374151;">ä½¿ç”¨é»˜è®¤ (batch=1, seq=50)</label>
                    </div>
                    <input type="text" id="symbolicDims" placeholder="ä¾‹å¦‚: batch_size=1, sequence_length=50">
                </div>

                 <button class="btn btn-primary" id="convertBtn" disabled>å¼€å§‹è½¬æ¢</button>
            </div>
        </div>

        <div class="panel">
            <!-- 3. Quantization -->
            <div class="section" style="flex:1; display:flex; flex-direction:column; border-bottom: none;">
                <div class="section-title" style="justify-content: space-between;">
                    <span>3. é‡åŒ–é…ç½® (QDQ)</span>
                </div>
                
                <div id="quantPanel" style="flex:1; display:flex; flex-direction:column; gap: 1rem;">
                    <div class="setting-group" style="margin-bottom:0;">
                        <div class="setting-row">
                            <label>Per-Channel é‡åŒ–</label>
                            <input type="checkbox" id="perChannel" checked>
                        </div>
                         <div class="setting-row">
                            <label>å…è®¸ Opset <= 10</label>
                            <input type="checkbox" id="allowOpset10">
                        </div>
                    </div>

                    <div style="border: 1px solid #e5e7eb; padding: 1rem; border-radius: var(--rounded); background: #f9fafb;">
                        <div style="font-size: 0.75rem; font-weight: 600; color: #374151; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            æ ¡å‡†æ•°æ®é›† (ZIP)
                            <button id="downloadExampleBtn" style="font-size: 0.65rem; padding: 2px 6px; border: 1px solid #bfdbfe; background: #eff6ff; color: #1e40af; border-radius: 4px; cursor: pointer; font-weight: 500;" title="ä¸‹è½½ç”Ÿæˆæ ¡å‡†æ•°æ®çš„ç¤ºä¾‹ç¨‹åº">ğŸ“ ç¤ºä¾‹</button>
                        </div>
                        <button class="btn btn-secondary" id="uploadCalibBtn" style="margin-top:0; font-size: 0.8rem; padding: 0.375rem;">é€‰æ‹©æ–‡ä»¶...</button>
                        <input type="file" id="calibInput" hidden accept=".zip">
                        <div id="calibInfo" style="font-size: 0.75rem; color: var(--success); margin-top: 0.5rem; font-weight: 500;"></div>
                    </div>

                    <div style="flex:1; display:flex; flex-direction:column; min-height: 0;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 0.5rem;">
                             <div style="font-size: 0.75rem; font-weight: 600; color: #374151;">é€‰æ‹©é‡åŒ–å±‚</div>
                             <div style="display: flex; gap: 4px;">
                                 <button id="btnSelectAll" style="font-size: 0.7rem; padding: 2px 6px; border: 1px solid #d1d5db; background: white; border-radius: 4px; cursor: pointer;">å…¨é€‰</button>
                                 <button id="btnClearAll" style="font-size: 0.7rem; padding: 2px 6px; border: 1px solid #d1d5db; background: white; border-radius: 4px; cursor: pointer;">æ¸…ç©º</button>
                             </div>
                        </div>
                        <div class="op-list" id="layerList">
                            <div style="text-align:center; color:#9ca3af; margin-top:40px; font-size: 0.85rem;">è¯·å…ˆåŠ è½½æ¨¡å‹</div>
                        </div>
                    </div>

                    <button class="btn btn-primary" id="quantizeBtn" style="background-color: var(--warning); border-color: var(--warning);">æ‰§è¡Œé‡åŒ–</button>
                </div>
            </div>
        </div>

        <!-- CENTER: Vis -->
        <div class="panel-center">
            <div id="graphContainer" style="flex: 2; min-height: 0;">
                <div id="graphPlaceholder" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #9ca3af;">
                    <h3 style="margin-bottom: 0.5rem; font-size: 1rem; font-weight: 500;">æ¨¡å‹ç»“æ„å¯è§†åŒ–</h3>
                    <p style="font-size: 0.875rem;">ä¸Šä¼  ONNX æ¨¡å‹ä»¥æŸ¥çœ‹å›¾ç»“æ„</p>
                </div>
                <canvas id="graphCanvas" style="display: none;"></canvas>
                <div class="graph-controls" id="graphControls" style="display: none;">
                    <button id="btnToggleLines" title="åˆ‡æ¢è¿çº¿æ˜¾ç¤º">âš¡</button>
                    <button id="btnZoomIn" title="æ”¾å¤§">+</button>
                    <button id="btnZoomOut" title="ç¼©å°">âˆ’</button>
                    <button id="btnZoomFit" title="é€‚åº”çª—å£">âŠ¡</button>
                    <button id="btnZoomReset" title="é‡ç½®">âŸ²</button>
                </div>
            </div>
            
            <div class="section" style="flex: 1; min-height: 200px; display:flex; flex-direction:column; background: white; border: 1px solid #e5e7eb; border-radius: var(--rounded-lg); overflow: hidden; padding: 0;">
                 <div class="section-title" style="padding: 0.75rem 1rem; background: #f9fafb; border-bottom: 1px solid #e5e7eb; margin: 0;">Python è¾“å‡º (stdout/stderr)</div>
                 <textarea id="pythonLog" style="flex:1; width:100%; border:none; resize:none; padding:1rem; font-family: ui-monospace, monospace; font-size: 0.75rem; color: #374151; background: #fff; line-height:1.5;" readonly placeholder="è½¬æ¢è¯¦æƒ…å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
            </div>
        </div>

        <!-- RIGHT: Logs & Results -->
        <div class="panel panel-right">
             <div class="section">
                 <div class="section-title">è½¬æ¢ç»“æœ</div>
                 <div id="resultsArea" class="hidden">
                    <div class="stat-card">
                        <div class="stat-row">
                             <span>åŸå§‹å¤§å°</span>
                             <span class="stat-val" id="resOrig">-</span>
                        </div>
                        <div class="stat-row">
                             <span>è½¬æ¢åå¤§å°</span>
                             <span class="stat-val" id="resNew">-</span>
                        </div>
                         <div class="stat-row">
                             <span>æ¨ç†è€—æ—¶ï¼ˆå¹³å‡ï¼‰</span>
                             <span class="stat-val" id="resTime">-</span>
                        </div>
                    </div>
                    
                    <div id="accuracyCard" class="stat-card hidden" style="background: #eff6ff; border-color: #bfdbfe;">
                        <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem; font-size: 0.85rem;">ç²¾åº¦å¯¹æ¯” (ONNX vs TFLite)</div>
                        <div class="stat-row" style="margin-bottom: 0.375rem;">
                             <span>æµ‹è¯•æ ·æœ¬æ•°</span>
                             <span class="stat-val" id="accSamples">-</span>
                        </div>
                        <div id="accuracyOutputs" style="font-size: 0.75rem; color: #374151;">
                            <!-- Per-output metrics will be inserted here -->
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" id="dlTflite" style="background-color: var(--success);">
                        <span>ä¸‹è½½ .tflite æ¨¡å‹</span>
                    </button>
                    <button class="btn btn-secondary" id="dlCpp">è½¬æ¢ä¸º C++å¤´æ–‡ä»¶ (.cc)</button>
                    <button class="btn btn-secondary" id="dlOnnxQ" class="hidden">ä¸‹è½½é‡åŒ–å ONNX</button>
                 </div>
                 <div id="noResults" style="text-align: center; color: #9ca3af; padding: 3rem 1rem; font-size: 0.875rem;">
                     ç­‰å¾…ä»»åŠ¡æ‰§è¡Œ...
                 </div>
             </div>

             <div class="section" style="flex: 1; display:flex; flex-direction:column; border-bottom: none; min-height: 15rem; padding:0;">
                 <div class="section-title" style="padding: 1rem 1rem 0 1rem;">ç³»ç»Ÿæ—¥å¿—</div>
                 <div class="console" id="console" style="flex:1; border-top: 1px solid #374151;"></div>
             </div>
             

        </div>
    </main>

    <script>
        // --- Logic ---
        const ui = {
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            convertBtn: document.getElementById('convertBtn'),
            quantizeBtn: document.getElementById('quantizeBtn'),
            console: document.getElementById('console'),
            layerList: document.getElementById('layerList'),
            quantPanel: document.getElementById('quantPanel'),
            resultsArea: document.getElementById('resultsArea'),
            noResults: document.getElementById('noResults')
        };

        const state = {
            filename: null,
            modelInfo: null,
            tfliteFilename: null,
            calibFilename: null,
            layerTypes: [],
            isQuantizing: false
        };

        function log(msg, type='info') {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            div.className = `log-${type}`;
            ui.console.appendChild(div);
            // Auto-scroll logic could be added here
            ui.console.scrollTop = ui.console.scrollHeight;
            document.getElementById('statusText').textContent = type === 'error' ? 'é”™è¯¯' : (type === 'success' ? 'å°±ç»ª' : 'å¤„ç†ä¸­...');
        }

        // --- Event Listeners ---
        
        // Drag & Drop
        ui.dropZone.onclick = () => ui.fileInput.click();
        ui.dropZone.ondragover = (e) => { e.preventDefault(); ui.dropZone.classList.add('active'); };
        ui.dropZone.ondragleave = () => ui.dropZone.classList.remove('active');
        ui.dropZone.ondrop = (e) => {
            e.preventDefault();
            ui.dropZone.classList.remove('active');
            handleUpload(e.dataTransfer.files[0]);
        };
        ui.fileInput.onchange = (e) => handleUpload(e.target.files[0]);

        // Default Dims Toggle
        document.getElementById('defaultDims').onchange = (e) => {
            const el = document.getElementById('symbolicDims');
            if(e.target.checked) {
                 el.value = "batch_size=1,sequence_length=50";
            } else {
                 if(el.value === "batch_size=1,sequence_length=50") el.value = "";
            }
        };

        // Calibration Upload
        document.getElementById('uploadCalibBtn').onclick = () => document.getElementById('calibInput').click();
        document.getElementById('calibInput').onchange = async (e) => {
            if(!e.target.files[0]) return;
            const fd = new FormData();
            fd.append('file', e.target.files[0]);
            log('æ­£åœ¨ä¸Šä¼ æ ¡å‡†æ•°æ®...', 'info');
            try {
                const res = await fetch('/upload_calibration', { method: 'POST', body: fd });
                const d = await res.json();
                if(d.success) {
                    state.calibFilename = d.filename;
                    document.getElementById('calibInfo').textContent = `å·²åŠ è½½: ${d.file_count} ä¸ª .npy æ–‡ä»¶`;
                    log(`æ ¡å‡†æ•°æ®åŠ è½½æˆåŠŸ: ${d.file_count} ä¸ªæ ·æœ¬`, 'success');
                } else {
                    log(d.error, 'error');
                }
            } catch(e) {
                log('ä¸Šä¼ å¤±è´¥', 'error');
            }
        };

        async function handleUpload(file) {
            if(!file || !file.name.endsWith('.onnx')) return log('ä»…æ”¯æŒ .onnx æ–‡ä»¶', 'error');
            
            const fd = new FormData();
            fd.append('file', file);
            log(`æ­£åœ¨ä¸Šä¼  ${file.name}...`, 'info');
            
            try {
                const res = await fetch('/upload', { method: 'POST', body: fd });
                const d = await res.json();
                if(d.success) {
                    state.filename = d.filename;
                    state.modelInfo = d.model_info;
                    document.getElementById('fileName').textContent = file.name;
                    ui.convertBtn.disabled = false;
                    log('æ¨¡å‹ä¸Šä¼ æˆåŠŸã€‚', 'success');
                    renderModel(d.model_info);
                } else {
                    log(d.error, 'error');
                }
            } catch(e) {
                log('ä¸Šä¼ é”™è¯¯', 'error');
            }
        }

        function renderModel(info) {
            // Populate Layer List for Quantization
            state.layerTypes = Object.keys(info.node_types).sort();
            
            ui.layerList.innerHTML = state.layerTypes.map(t => {
                return `<label class="op-item"><input type="checkbox" value="${t}" checked> ${t}</label>`;
            }).join('');

            // Render Graph Visualization
            renderGraphVisualization(info);
        }
        
        // ========== Graph Visualization Engine ==========
        
        const graphState = {
            scale: 1,
            translateX: 0,
            translateY: 0,
            isDragging: false,
            startX: 0,
            startY: 0,
            showLines: true,  // Default: show lines
            layout: null,
            canvas: null,
            ctx: null
        };
        
        function renderGraphVisualization(info) {
            if (!info.nodes || !info.edges) {
                console.warn('No graph structure data available');
                return;
            }
            
            document.getElementById('graphPlaceholder').style.display = 'none';
            const canvas = document.getElementById('graphCanvas');
            canvas.style.display = 'block';
            document.getElementById('graphControls').style.display = 'flex';
            
            // Setup canvas
            graphState.canvas = canvas;
            graphState.ctx = canvas.getContext('2d');
            resizeCanvas();
            
            // Calculate layout
            graphState.layout = calculateGraphLayout(info);
            
            // Render to Canvas
            renderToCanvas();
            
            // Set initial button state for toggle lines
            const btnToggle = document.getElementById('btnToggleLines');
            if (graphState.showLines) {
                btnToggle.classList.add('active');
            } else {
                btnToggle.classList.remove('active');
            }
            
            // Reset view to fit
            setTimeout(() => fitToView(), 100);
        }
        
        function resizeCanvas() {
            const container = document.getElementById('graphContainer');
            const canvas = graphState.canvas;
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            
            graphState.ctx.scale(dpr, dpr);
            
            if (graphState.layout) {
                renderToCanvas();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        function calculateGraphLayout(info) {
            const nodeWidth = 180;
            const nodeHeight = 80;
            const layerSpacing = 120;  // Vertical spacing between layers
            const nodeSpacing = 220;   // Horizontal spacing between nodes
            
            // Build adjacency information
            const nodeMap = new Map();
            const inDegree = new Map();
            const outEdges = new Map();
            
            // Add input nodes
            info.inputs.forEach(inp => {
                const id = `input_${inp.name}`;
                nodeMap.set(id, { id, type: 'input', label: inp.name, shape: inp.shape, layer: 0 });
                inDegree.set(id, 0);
                outEdges.set(id, []);
            });
            
            // Add operation nodes
            info.nodes.forEach(node => {
                nodeMap.set(node.id, { ...node, label: node.name, type: 'op', layer: -1 });
                inDegree.set(node.id, 0);
                outEdges.set(node.id, []);
            });
            
            // Add output nodes
            info.outputs.forEach(out => {
                const id = `output_${out.name}`;
                nodeMap.set(id, { id, type: 'output', label: out.name, shape: out.shape, layer: -1 });
                inDegree.set(id, 0);
                outEdges.set(id, []);
            });
            
            // Build edge connections
            info.edges.forEach(edge => {
                if (nodeMap.has(edge.from) && nodeMap.has(edge.to)) {
                    outEdges.get(edge.from).push(edge.to);
                    inDegree.set(edge.to, (inDegree.get(edge.to) || 0) + 1);
                }
            });
            
            // Topological sort to assign layers
            const queue = [];
            nodeMap.forEach((node, id) => {
                if (inDegree.get(id) === 0) {
                    queue.push(id);
                }
            });
            
            while (queue.length > 0) {
                const current = queue.shift();
                const currentNode = nodeMap.get(current);
                
                outEdges.get(current).forEach(neighbor => {
                    const neighborNode = nodeMap.get(neighbor);
                    neighborNode.layer = Math.max(neighborNode.layer, currentNode.layer + 1);
                    
                    inDegree.set(neighbor, inDegree.get(neighbor) - 1);
                    if (inDegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }
            
            // Group nodes by layer
            const layers = [];
            nodeMap.forEach(node => {
                if (!layers[node.layer]) layers[node.layer] = [];
                layers[node.layer].push(node);
            });
            
            // Assign positions (vertical layout)
            const positions = new Map();
            layers.forEach((layerNodes, layerIdx) => {
                const y = layerIdx * layerSpacing + 80;  // Vertical position
                layerNodes.forEach((node, idx) => {
                    const totalWidth = (layerNodes.length - 1) * nodeSpacing;
                    const x = idx * nodeSpacing - totalWidth / 2 + 400;  // Horizontal position
                    positions.set(node.id, { 
                        x, y, 
                        width: nodeWidth, 
                        height: nodeHeight,
                        node 
                    });
                });
            });

            return { positions, edges: info.edges, nodeMap, tensorShapes: buildTensorShapeMap(info) };
        }
        
        function buildTensorShapeMap(info) {
            const shapeMap = new Map();
            
            // Use tensor_shapes from backend if available
            if (info.tensor_shapes) {
                for (const [tensorName, shape] of Object.entries(info.tensor_shapes)) {
                    shapeMap.set(tensorName, shape);
                }
            }
            
            // Map input shapes
            info.inputs.forEach(inp => {
                if (!shapeMap.has(inp.name)) {
                    shapeMap.set(inp.name, inp.shape);
                }
            });
            
            // Map output shapes
            info.outputs.forEach(out => {
                if (!shapeMap.has(out.name)) {
                    shapeMap.set(out.name, out.shape);
                }
            });
            
            return shapeMap;
        }
        
        function renderToCanvas() {
            const ctx = graphState.ctx;
            const canvas = graphState.canvas;
            const layout = graphState.layout;
            
            if (!ctx || !layout) return;
            
            // Clear canvas
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply transformations
            ctx.translate(graphState.translateX, graphState.translateY);
            ctx.scale(graphState.scale, graphState.scale);
            
            // Draw edges first (behind nodes) if enabled
            if (graphState.showLines) {
                layout.edges.forEach(edge => {
                    const from = layout.positions.get(edge.from);
                    const to = layout.positions.get(edge.to);
                    
                    if (from && to) {
                        // Vertical layout: from bottom to top
                        const x1 = from.x + from.width / 2;
                        const y1 = from.y + from.height;
                        const x2 = to.x + to.width / 2;
                        const y2 = to.y;
                        
                        // Draw curved line
                        const midY = (y1 + y2) / 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.bezierCurveTo(x1, midY, x2, midY, x2, y2);
                        ctx.strokeStyle = '#cbd5e1';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Draw arrow
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const arrowSize = 8;
                        ctx.beginPath();
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 - arrowSize * Math.cos(angle - Math.PI / 6),
                            y2 - arrowSize * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.lineTo(
                            x2 - arrowSize * Math.cos(angle + Math.PI / 6),
                            y2 - arrowSize * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.closePath();
                        ctx.fillStyle = '#cbd5e1';
                        ctx.fill();
                    }
                });
            }
            
            // Draw nodes
            layout.positions.forEach(pos => {
                const x = pos.x;
                const y = pos.y;
                const w = pos.width;
                const h = pos.height;
                const node = pos.node;
                
                // Draw card shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                
                // Draw card background
                ctx.fillStyle = '#ffffff';
                if (node.type === 'input') {
                    ctx.fillStyle = '#e0f2fe';
                } else if (node.type === 'output') {
                    ctx.fillStyle = '#dcfce7';
                }
                
                roundRect(ctx, x, y, w, h, 8);
                ctx.fill();
                
                // Draw border
                ctx.shadowColor = 'transparent';
                ctx.strokeStyle = '#e5e7eb';
                if (node.type === 'input') {
                    ctx.strokeStyle = '#0ea5e9';
                } else if (node.type === 'output') {
                    ctx.strokeStyle = '#22c55e';
                }
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node text
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let labelText = node.label || node.id;
                if (labelText.length > 20) labelText = labelText.substring(0, 17) + '...';
                ctx.fillText(labelText, x + w / 2, y + h / 2 - 16);
                
                // Draw operation type
                ctx.fillStyle = '#64748b';
                ctx.font = '10px ui-monospace, monospace';
                
                let subtext = '';
                if (node.type === 'op') {
                    subtext = node.op_type;
                } else if (node.shape) {
                    const shapeStr = JSON.stringify(node.shape);
                    subtext = shapeStr.length > 25 ? shapeStr.substring(0, 22) + '...' : shapeStr;
                }
                ctx.fillText(subtext, x + w / 2, y + h / 2);
                
                // Draw input shape info
                if (node.type === 'op' && node.inputs && node.inputs.length > 0) {
                    const inputShape = getInputShape(node, layout.tensorShapes);
                    if (inputShape) {
                        ctx.fillStyle = '#059669';
                        ctx.font = '9px ui-monospace, monospace';
                        const shapeText = 'In: ' + formatShape(inputShape);
                        ctx.fillText(shapeText, x + w / 2, y + h / 2 + 16);
                    }
                }
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
            });
            
            ctx.restore();
        }
        
        // Helper function to get input shape
        function getInputShape(node, tensorShapes) {
            if (!node.inputs || node.inputs.length === 0) return null;
            
            // Get the first input tensor's shape
            const firstInput = node.inputs[0];
            if (tensorShapes && tensorShapes.has(firstInput)) {
                return tensorShapes.get(firstInput);
            }
            
            return null;
        }
        
        // Helper function to format shape array
        function formatShape(shape) {
            if (!shape || shape.length === 0) return '?';
            return '[' + shape.map(dim => {
                if (typeof dim === 'string') return dim;
                if (typeof dim === 'number') return dim;
                return '?';
            }).join(',') + ']';
        }
        
        // Helper function to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }
        
        function updateTransform() {
            renderToCanvas();
        }
        
        function fitToView() {
            if (!graphState.layout) return;
            
            const layout = graphState.layout;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            layout.positions.forEach(pos => {
                minX = Math.min(minX, pos.x);
                minY = Math.min(minY, pos.y);
                maxX = Math.max(maxX, pos.x + pos.width);
                maxY = Math.max(maxY, pos.y + pos.height);
            });
            
            const bbox = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
            
            if (bbox.width === 0 || bbox.height === 0) return;
            
            const container = document.getElementById('graphContainer');
            const padding = 50;
            const scaleX = (container.clientWidth - padding * 2) / bbox.width;
            const scaleY = (container.clientHeight - padding * 2) / bbox.height;
            const scale = Math.min(scaleX, scaleY, 1);
            
            graphState.scale = scale;
            graphState.translateX = (container.clientWidth - bbox.width * scale) / 2 - bbox.x * scale;
            graphState.translateY = (container.clientHeight - bbox.height * scale) / 2 - bbox.y * scale;
            
            updateTransform();
        }
        
        // ========== Graph Controls ==========
        
        document.getElementById('btnToggleLines').onclick = () => {
            graphState.showLines = !graphState.showLines;
            const btn = document.getElementById('btnToggleLines');
            if (graphState.showLines) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            renderToCanvas();
        };
        
        document.getElementById('btnZoomIn').onclick = () => {
            graphState.scale *= 1.2;
            updateTransform();
        };
        
        document.getElementById('btnZoomOut').onclick = () => {
            graphState.scale /= 1.2;
            updateTransform();
        };
        
        document.getElementById('btnZoomFit').onclick = fitToView;
        
        document.getElementById('btnZoomReset').onclick = () => {
            graphState.scale = 1;
            graphState.translateX = 0;
            graphState.translateY = 0;
            updateTransform();
        };
        
        // Panning with mouse drag
        const graphContainer = document.getElementById('graphContainer');
        
        graphContainer.addEventListener('mousedown', (e) => {
            if (e.target === graphContainer || e.target.id === 'graphCanvas') {
                graphState.isDragging = true;
                graphState.startX = e.clientX - graphState.translateX;
                graphState.startY = e.clientY - graphState.translateY;
                graphContainer.classList.add('grabbing');
            }
        });
        
        graphContainer.addEventListener('mousemove', (e) => {
            if (graphState.isDragging) {
                graphState.translateX = e.clientX - graphState.startX;
                graphState.translateY = e.clientY - graphState.startY;
                updateTransform();
            }
        });
        
        graphContainer.addEventListener('mouseup', () => {
            graphState.isDragging = false;
            graphContainer.classList.remove('grabbing');
        });
        
        graphContainer.addEventListener('mouseleave', () => {
            graphState.isDragging = false;
            graphContainer.classList.remove('grabbing');
        });
        
        // Zoom with mouse wheel
        graphContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            graphState.scale *= delta;
            updateTransform();
        });

        function getSettings() {
            return {
                allowInputsStripping: document.getElementById('allowInputsStripping').checked,
                keepIoFormat: document.getElementById('keepIoFormat').checked,
                skipShapeInference: document.getElementById('skipShapeInference').checked,
                allowSelectOps: document.getElementById('allowSelectOps').checked,
                castInt64ToInt32: document.getElementById('castInt64ToInt32').checked,
                symbolicDims: document.getElementById('symbolicDims').value,
                perChannel: document.getElementById('perChannel').checked,
                allowOpset10: document.getElementById('allowOpset10').checked
            };
        }

        // Conversion
        ui.convertBtn.onclick = async () => {
            if(!state.filename) return;
            log('å¼€å§‹æ ‡å‡†è½¬æ¢ä»»åŠ¡...', 'info');
            document.getElementById('pythonLog').value = "æ­£åœ¨è¿è¡Œ...";
            ui.convertBtn.disabled = true;
            
            try {
                const res = await fetch('/convert', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        filename: state.filename,
                        settings: getSettings()
                    })
                });
                const d = await res.json();
                if(d.logs) document.getElementById('pythonLog').value = d.logs;
                
                if(d.success) {
                    showResults(d);
                    log('è½¬æ¢å®Œæˆ!', 'success');
                } else {
                    log('é”™è¯¯: ' + d.error, 'error');
                }
            } catch(e) { log('ç½‘ç»œ/æœåŠ¡å™¨é”™è¯¯', 'error'); }
            finally { ui.convertBtn.disabled = false; }
        };

        // Quantization
        ui.quantizeBtn.onclick = async () => {
             if(!state.filename) return;
             
             // Get selected layers
             const selected = Array.from(ui.layerList.querySelectorAll('input:checked')).map(cb => cb.value);
             if(selected.length === 0) return log('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§é‡åŒ–å±‚ç±»å‹!', 'error');

             log('å¼€å§‹é‡åŒ–åŠè½¬æ¢ä»»åŠ¡...', 'info');
             document.getElementById('pythonLog').value = "æ­£åœ¨è¿è¡Œé‡åŒ–ä»»åŠ¡...";
             ui.quantizeBtn.disabled = true;
             
             try {
                const res = await fetch('/quantize', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        filename: state.filename,
                        settings: getSettings(),
                        selectedLayers: selected,
                        calibFilename: state.calibFilename
                    })
                });
                const d = await res.json();
                if(d.logs) document.getElementById('pythonLog').value = d.logs;
                
                if(d.success) {
                    state.tfliteFilename = d.quantized_tflite_filename;
                    
                    ui.noResults.classList.add('hidden');
                    ui.resultsArea.classList.remove('hidden');
                    
                    // Display statistics
                    if(d.stats) {
                        document.getElementById('resOrig').textContent = (d.stats.original_size/1024).toFixed(2) + " KB";
                        document.getElementById('resNew').textContent = (d.stats.converted_size/1024).toFixed(2) + " KB";
                        document.getElementById('resTime').textContent = d.stats.time;
                    }
                    
                    const btnQ = document.getElementById('dlOnnxQ');
                    btnQ.classList.remove('hidden');
                    btnQ.onclick = () => window.location.href = `/download/${d.quantized_onnx_filename}`;
                    
                    // Display accuracy comparison if available
                    if(d.accuracy) {
                        displayAccuracy(d.accuracy);
                    } else {
                        document.getElementById('accuracyCard').classList.add('hidden');
                    }

                    log('é‡åŒ–å®Œæˆ!', 'success');
                } else {
                    log('é”™è¯¯: ' + d.error, 'error');
                }
             } catch(e) { log('ç½‘ç»œé”™è¯¯', 'error'); }
             finally { ui.quantizeBtn.disabled = false; }
        };

        function showResults(data) {
            state.tfliteFilename = data.tflite_filename;
            
            // Only update results view if this was a successful run
            if(data.success) {
                ui.noResults.classList.add('hidden');
                document.getElementById('resultsArea').classList.remove('hidden');

                if(data.stats) {
                    document.getElementById('resOrig').textContent = (data.stats.original_size/1024).toFixed(2) + " KB";
                    document.getElementById('resNew').textContent = (data.stats.converted_size/1024).toFixed(2) + " KB";
                    document.getElementById('resTime').textContent = data.stats.time;
                }
                
                // Display accuracy comparison if available
                if(data.accuracy) {
                    displayAccuracy(data.accuracy);
                } else {
                    document.getElementById('accuracyCard').classList.add('hidden');
                }
            } else {
                 if(data.error) log('è½¬æ¢å¤±è´¥: ' + data.error, 'error');
            }
        }

        function displayAccuracy(accuracy) {
            const card = document.getElementById('accuracyCard');
            const samplesEl = document.getElementById('accSamples');
            const outputsEl = document.getElementById('accuracyOutputs');
            
            card.classList.remove('hidden');
            samplesEl.textContent = accuracy.num_samples;
            
            // Clear previous outputs
            outputsEl.innerHTML = '';
            
            // Display each output's metrics
            accuracy.outputs.forEach((output, idx) => {
                const outputDiv = document.createElement('div');
                outputDiv.style.cssText = 'margin-top: 0.5rem; padding: 0.5rem; background: white; border-radius: 4px; border: 1px solid #e5e7eb;';
                
                let outputName = output.output_name;
                if (outputName.length > 25) {
                    outputName = outputName.substring(0, 22) + '...';
                }
                
                outputDiv.innerHTML = `
                    <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.25rem;">${outputName}</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.25rem; font-size: 0.7rem;">
                        <div>MAE: <span style="font-family: monospace; font-weight: 600;">${output.mae.toExponential(3)}</span></div>
                        <div>RMSE: <span style="font-family: monospace; font-weight: 600;">${output.rmse.toExponential(3)}</span></div>
                        <div>ä½™å¼¦ç›¸ä¼¼åº¦: <span style="font-family: monospace; font-weight: 600;">${output.cosine_similarity.toFixed(6)}</span></div>
                        <div>æœ€å¤§è¯¯å·®: <span style="font-family: monospace; font-weight: 600;">${output.max_error.toExponential(3)}</span></div>
                    </div>
                `;
                
                outputsEl.appendChild(outputDiv);
            });
        }

        document.getElementById('dlTflite').onclick = () => {
            if(state.tfliteFilename) window.location.href = `/download/${state.tfliteFilename}`;
        };

        document.getElementById('dlCpp').onclick = async () => {
            if(!state.tfliteFilename) return;
            log('æ­£åœ¨ç”Ÿæˆ C++ æ•°ç»„...', 'info');
            const res = await fetch('/convert_to_cpp', {
                 method: 'POST', headers: {'Content-Type': 'application/json'},
                 body: JSON.stringify({filename: state.tfliteFilename})
            });
            const d = await res.json();
            if(d.success) window.location.href = `/download/${d.cpp_filename}`;
            else log('C++ è½¬æ¢å¤±è´¥', 'error');
        };

        // Select All / Clear All
        document.getElementById('btnSelectAll').onclick = () => {
            ui.layerList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        };
        document.getElementById('btnClearAll').onclick = () => {
            ui.layerList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        };

        // Download calibration data generator example
        document.getElementById('downloadExampleBtn').onclick = () => {
            if(!state.modelInfo) {
                log('è¯·å…ˆä¸Šä¼ æ¨¡å‹ä»¥è·å–è¾“å…¥ä¿¡æ¯', 'error');
                return;
            }
            window.location.href = '/download_calib_generator';
        };

    </script>
</body>
</html>
